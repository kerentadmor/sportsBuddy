<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SportsBuddy AI - ××•×¦× ××ª×§× ×™ ×¡×¤×•×¨×˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            direction: rtl;
        }

        .chat-container {
            width: 400px;
            height: 700px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .header-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .header-subtitle {
            font-size: 12px;
            opacity: 0.9;
        }

        .new-chat-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .new-chat-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .status-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
        }

        .messages-container {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.bot { justify-content: flex-start; }
        .message.user { justify-content: flex-end; }

        .message-bubble {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .message.bot .message-bubble {
            background: white;
            border: 1px solid #e1e8ed;
            margin-right: 8px;
        }

        .message.user .message-bubble {
            background: #4CAF50;
            color: white;
            margin-left: 8px;
        }

        .facility-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .facility-name {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .facility-type {
            background: #e8f5e8;
            color: #2e7d2e;
            padding: 3px 8px;
            border-radius: 8px;
            font-size: 11px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .facility-details {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
        }

        .facility-link {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            text-decoration: none;
            font-size: 12px;
            margin-top: 10px;
            margin-left: 8px;
            transition: background 0.3s;
        }

        .facility-link:hover {
            background: #45a049;
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            background: white;
            border: 1px solid #e1e8ed;
            border-radius: 16px;
            margin-right: 8px;
            max-width: 60px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
        }

        .input-container {
            display: flex;
            padding: 15px;
            background: white;
            border-top: 1px solid #e1e8ed;
        }

        .message-input {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 10px 16px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
            direction: rtl;
        }

        .message-input:focus {
            border-color: #4CAF50;
        }

        .send-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            margin-left: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .send-btn:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        @media (max-width: 450px) {
            .chat-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }
        }

        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        .show-more-btn {
            background: #f0f8ff;
            border: 2px solid #4CAF50;
            color: #4CAF50;
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: inline-block;
            margin: 10px 0;
            transition: all 0.3s;
            text-align: center;
            width: 100%;
        }

        .show-more-btn:hover {
            background: #4CAF50;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #ffcdd2;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <button class="new-chat-btn" onclick="startNewConversation()">ğŸ”„ ×©×™×—×” ×—×“×©×”</button>
            <div class="status-badge" id="statusBadge">×˜×•×¢×Ÿ × ×ª×•× ×™×...</div>
            <div class="header-title">SportsBuddy AI</div>
            <div class="header-subtitle">××•×¦× ××ª×§× ×™ ×¡×¤×•×¨×˜ ×‘×™×©×¨××œ - ×¢× ××–×’ ××•×•×™×¨!</div>
        </div>
        
        <div class="messages-container" id="messagesContainer">
            <div class="message bot">
                <div class="message-bubble">
                    <div class="loading-indicator" id="loadingMessage">
                        ğŸ”„ ×˜×•×¢×Ÿ × ×ª×•× ×™ ××ª×§× ×™ ×¡×¤×•×¨×˜...<br>
                        ×× × ×”××ª×Ÿ...
                    </div>
                </div>
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        
        <div class="input-container">
            <input type="text" class="message-input" id="messageInput" placeholder="×›×ª×•×‘ ××” ××ª×” ××—×¤×©..." onkeypress="handleKeyPress(event)" disabled>
            <button class="send-btn" onclick="sendMessage()" disabled id="sendButton">
                â¤
            </button>
        </div>
    </div>

    <script>
        // Global variables
        let sportsData = [];
        let isDataLoaded = false;
        let dataSource = 'unknown';
        
        // Weather API configuration
        const WEATHER_API_KEY = '0822972733a5c06eb6d8f1e51dc0cec3';
        const WEATHER_API_URL = 'https://api.openweathermap.org/data/2.5/weather';
        
        // Conversation state
        let conversationState = {
            intent: null,
            slots: {
                location: null,
                facility_type: null,
                accessibility: null,
                parking: null,
                lighting: null,
                time: null
            },
            weatherChecked: false,
            weatherData: null,
            searchResults: [],
            currentPage: 0,
            resultsPerPage: 3,
            showMorePerPage: 10
        };

        // Outdoor facilities that need weather check
        const OUTDOOR_FACILITIES = ['×›×“×•×¨×’×œ', '×˜× ×™×¡', '×›×“×•×¨×¢×£', '××™× ×™'];

        // Enhanced facility mappings
        const FACILITY_MAPPINGS = {
            '××•×œ×': ['××•×œ× ×¡×¤×•×¨×˜ ×§×˜×Ÿ', '××•×œ× ×¡×¤×•×¨×˜ ×‘×™× ×•× ×™', '××•×œ× ×¡×¤×•×¨×˜ ×’×“×•×œ', '××•×œ× ×”×ª×¢××œ×•×ª', '××•×œ× ×¡×¤×•×¨×˜', '××•×œ×'],
            '×¡×¤×•×¨×˜': ['××•×œ× ×¡×¤×•×¨×˜', '××’×¨×© ×¡×¤×•×¨×˜', '××ª×§×Ÿ ×¡×¤×•×¨×˜'],
            '×”×ª×¢××œ×•×ª': ['××•×œ× ×”×ª×¢××œ×•×ª', '××•×œ× ×¡×¤×•×¨×˜', '×”×ª×¢××œ×•×ª'],
            '×‘×¨×™×›×”': ['×‘×¨×™×›×ª ×©×—×™×” - 25X12.5 ×\'', '×‘×¨×™×›×ª ×©×—×™×” - 20X50 ×\'', '×‘×¨×™×›×ª ×©×—×™×” ×‘××™×“×•×ª ××—×¨×•×ª', '×‘×¨×™×›×ª ×©×—×™×”', '×‘×¨×™×›×”', '×‘×¨×™×›×ª'],
            '×©×—×™×™×”': ['×‘×¨×™×›×ª ×©×—×™×” - 25X12.5 ×\'', '×‘×¨×™×›×ª ×©×—×™×” - 20X50 ×\'', '×‘×¨×™×›×ª ×©×—×™×” ×‘××™×“×•×ª ××—×¨×•×ª', '×‘×¨×™×›×ª ×©×—×™×”', '×‘×¨×™×›×”', '×©×—×™×”'],
            '×©×—×™×”': ['×‘×¨×™×›×ª ×©×—×™×” - 25X12.5 ×\'', '×‘×¨×™×›×ª ×©×—×™×” - 20X50 ×\'', '×‘×¨×™×›×ª ×©×—×™×” ×‘××™×“×•×ª ××—×¨×•×ª', '×‘×¨×™×›×ª ×©×—×™×”', '×‘×¨×™×›×”', '×©×—×™×”'],
            '×›×“×•×¨×’×œ': ['××’×¨×© ×›×“×•×¨×’×œ', '××¦×˜×“×™×•×Ÿ ×›×“×•×¨×’×œ', '××’×¨×© ×¡×¤×•×¨×˜ ××©×•×œ×‘', '×›×“×•×¨×’×œ', '××’×¨×© ×“×©×'],
            '×›×“×•×¨×¡×œ': ['××’×¨×© ×›×“×•×¨×¡×œ', '××•×œ× ×¡×¤×•×¨×˜', '×›×“×•×¨×¡×œ'],
            '×˜× ×™×¡': ['××’×¨×© ×˜× ×™×¡', '×˜× ×™×¡'],
            '×›×“×•×¨×¢×£': ['××’×¨×© ×—×•×œ ×§×‘×•×¢ ×œ×›×“×•×¨×¢×£', '××’×¨×© ×›×“×•×¨×¢×£', '×›×“×•×¨×¢×£', '×—×•×œ'],
            '×›×•×©×¨': ['××›×•×Ÿ ×œ×›×•×©×¨ ×’×•×¤× ×™', '××ª×§×Ÿ ×¤×ª×•×— ×œ×›×•×©×¨ ×’×•×¤× ×™', '×›×•×©×¨', '×¤×™×˜× ×¡'],
            '××™× ×™': ['××’×¨×© ××™× ×™ ×¤×™×¥\'', '××™× ×™'],
            '×—×•×œ': ['××’×¨×© ×—×•×œ ×§×‘×•×¢', '×—×•×œ']
        };
        
        // Current date helper
        function getCurrentDate() {
            const now = new Date();
            const days = ['×¨××©×•×Ÿ', '×©× ×™', '×©×œ×™×©×™', '×¨×‘×™×¢×™', '×—××™×©×™', '×©×™×©×™', '×©×‘×ª'];
            const dayName = days[now.getDay()];
            const date = now.getDate().toString().padStart(2, '0');
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const year = now.getFullYear();
            return `×™×•× ${dayName}, ${date}/${month}/${year}`;
        }

        // Weather API integration with time consideration
        async function getWeatherDataForTime(cityName, requestedTime) {
            try {
                console.log('ğŸŒ¤ï¸ Fetching weather for:', cityName, 'at time:', requestedTime);
                
                // Convert Hebrew city name to English for better API compatibility
                const englishCityName = getEnglishCityName(cityName);
                console.log('ğŸŒ Using English city name:', englishCityName);
                
                const cleanCityName = englishCityName.replace(/[Ö¾\-]/, ' ').trim();
                
                // Determine if we need current weather or forecast
                const needsForecast = ['××—×¨', '××—×¨×ª×™×™×', '×”×©×‘×•×¢', '×¡×•×£ ×”×©×‘×•×¢'].includes(requestedTime);
                
                if (needsForecast) {
                    // Try to get 5-day forecast for future times
                    const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(cleanCityName)}&appid=${WEATHER_API_KEY}&units=metric&lang=he`;
                    console.log('ğŸ”— Weather Forecast API URL:', forecastUrl);
                    
                    const response = await fetch(forecastUrl);
                    console.log('ğŸ“¡ Forecast API Response status:', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('âœ… Forecast data received');
                        
                        // Find the most relevant forecast entry for the requested time
                        const relevantForecast = findRelevantForecast(data.list, requestedTime);
                        
                        if (relevantForecast) {
                            return {
                                temp: Math.round(relevantForecast.main.temp),
                                description: relevantForecast.weather[0].description,
                                main: relevantForecast.weather[0].main,
                                cityName: data.city.name,
                                forecastTime: requestedTime,
                                isForecast: true
                            };
                        }
                    }
                }
                
                // Fallback to current weather API
                const currentUrl = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(cleanCityName)}&appid=${WEATHER_API_KEY}&units=metric&lang=he`;
                console.log('ğŸ”— Current Weather API URL:', currentUrl);
                
                const response = await fetch(currentUrl);
                console.log('ğŸ“¡ Current API Response status:', response.status);
                
                if (!response.ok) {
                    console.log('âŒ Weather API failed:', response.status, response.statusText);
                    
                    try {
                        const errorData = await response.json();
                        console.log('âŒ Error details:', errorData);
                    } catch (e) {
                        console.log('âŒ Could not parse error response');
                    }
                    
                    return null;
                }
                
                const data = await response.json();
                console.log('âœ… Current weather data received:', data);
                
                return {
                    temp: Math.round(data.main.temp),
                    description: data.weather[0].description,
                    main: data.weather[0].main,
                    cityName: data.name,
                    forecastTime: requestedTime,
                    isForecast: false
                };
                
            } catch (error) {
                console.error('ğŸ’¥ Weather API error:', error);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    console.error('ğŸš« Likely CORS error - try running on a web server instead of file://');
                }
                
                return null;
            }
        }

        // Find the most relevant forecast entry for the requested time
        function findRelevantForecast(forecastList, requestedTime) {
            if (!forecastList || forecastList.length === 0) return null;
            
            const now = new Date();
            let targetDate = new Date();
            
            // Calculate target date based on requested time
            switch (requestedTime) {
                case '××—×¨':
                    targetDate.setDate(now.getDate() + 1);
                    targetDate.setHours(12); // Default to noon
                    break;
                case '××—×¨×ª×™×™×':
                    targetDate.setDate(now.getDate() + 2);
                    targetDate.setHours(12);
                    break;
                default:
                    // For other times, try to find closest forecast (usually within next 24 hours)
                    targetDate.setHours(now.getHours() + 3); // 3 hours from now as default
                    break;
            }
            
            // Find forecast entry closest to target time
            let closestForecast = forecastList[0];
            let minTimeDiff = Math.abs(new Date(forecastList[0].dt * 1000) - targetDate);
            
            for (const forecast of forecastList) {
                const forecastTime = new Date(forecast.dt * 1000);
                const timeDiff = Math.abs(forecastTime - targetDate);
                
                if (timeDiff < minTimeDiff) {
                    minTimeDiff = timeDiff;
                    closestForecast = forecast;
                }
            }
            
            return closestForecast;
        }

        // Legacy function for backward compatibility
        async function getWeatherData(cityName) {
            return await getWeatherDataForTime(cityName, '×¢×›×©×™×•');
        }

        // Context-aware weather feedback with time consideration
        function getContextualWeatherFeedback(weatherData) {
            if (!weatherData) return null;
            
            const { temp, main, description, cityName, forecastTime, isForecast } = weatherData;
            
            // Create time-appropriate message header
            let timeContext = '';
            if (isForecast) {
                timeContext = ` ×œ${getTimeDisplayName(forecastTime)}`;
            } else if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                timeContext = ` (×ª×—×–×™×ª ×¢×‘×•×¨ ${getTimeDisplayName(forecastTime)} ××‘×•×¡×¡×ª ×¢×œ ××–×’ ××•×•×™×¨ × ×•×›×—×™)`;
            }
            
            let feedback = `ğŸŒ¤ï¸ <strong>××–×’ ×”××•×•×™×¨ ×‘${cityName}${timeContext}:</strong> ${temp}Â°C, ${description}<br><br>`;
            
            // Rain/Storm conditions
            if (main === 'Rain' || main === 'Thunderstorm' || main === 'Snow') {
                if (forecastTime === '××—×¨' || forecastTime === '××—×¨×ª×™×™×') {
                    feedback += 'ğŸŒ§ï¸ <strong>×¦×¤×•×™ ×’×©× â€“ ××•××œ×¥ ×œ×©×§×•×œ ××ª×§×Ÿ ×¡×¤×•×¨×˜ ××§×•×¨×”.</strong><br>';
                } else {
                    feedback += 'ğŸŒ§ï¸ <strong>×™×•×¨×“ ×’×©× ×›×¨×’×¢ â€“ ××•××œ×¥ ×œ×©×§×•×œ ××ª×§×Ÿ ×¡×¤×•×¨×˜ ××§×•×¨×”.</strong><br>';
                }
                feedback += '××ª×§× ×™× ××§×•×¨×™× ×›××• ××•×œ××•×ª ×¡×¤×•×¨×˜ ×•×‘×¨×™×›×•×ª ×™×”×™×• ××™×“×™××œ×™×™×!';
            }
            // Extreme heat
            else if (temp > 32) {
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += 'ğŸ”¥ <strong>×¦×¤×•×™ ×—×•× ×§×™×¦×•× ×™. ××•××œ×¥ ×œ×”×™×–×”×¨ ××”×©××©, ×œ×©×ª×•×ª ×”×¨×‘×” ××™×, ×•×œ×”×ª×××Ÿ ×‘×©×¢×•×ª ×”×§×¨×™×¨×•×ª ×™×•×ª×¨.</strong><br><br>';
                } else {
                    feedback += 'ğŸ”¥ <strong>×—×•× ×§×™×¦×•× ×™ ×›×¨×’×¢. ××•××œ×¥ ×œ×”×™×–×”×¨ ××”×©××©, ×œ×©×ª×•×ª ×”×¨×‘×” ××™×, ×•×œ×”×ª×××Ÿ ×‘×©×¢×•×ª ×”×§×¨×™×¨×•×ª ×™×•×ª×¨.</strong><br><br>';
                }
                feedback += 'ğŸ’¡ ×©×§×•×œ ×œ×—×¤×© ××ª×§×Ÿ ××§×•×¨×” ××• ×œ×ª×›× ×Ÿ ×¤×¢×™×œ×•×ª ×‘×©×¢×•×ª ×”×‘×•×§×¨ ×”××•×§×“××•×ª!';
            }
            // Very cold
            else if (temp < 10) {
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += 'ğŸ¥¶ <strong>×¦×¤×•×™ ×§×•×¨ - ×”×§×¤×“ ×œ×”×ª×—×× ×”×™×˜×‘ ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª ×•×œ×”×œ×‘×™×© ×©×›×‘×•×ª.</strong><br>';
                } else {
                    feedback += 'ğŸ¥¶ <strong>×§×¨ ×‘×—×•×¥ - ×”×§×¤×“ ×œ×”×ª×—×× ×”×™×˜×‘ ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª ×•×œ×”×œ×‘×™×© ×©×›×‘×•×ª.</strong><br>';
                }
                feedback += '××ª×§× ×™× ××§×•×¨×™× ×™×”×™×• × ×•×—×™× ×™×•×ª×¨ ×‘××–×’ ××•×•×™×¨ ×›×–×”.';
            }
            // Perfect weather
            else if (temp >= 18 && temp <= 25) {
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += 'â˜€ï¸ <strong>×¦×¤×•×™ ××–×’ ××•×•×™×¨ ××•×©×œ× - ××¤×©×¨ ×œ×”×ª×××Ÿ ×‘×›×œ ××§×•×!</strong><br>';
                } else {
                    feedback += 'â˜€ï¸ <strong>××–×’ ××•×•×™×¨ ××•×©×œ× - ××¤×©×¨ ×œ×”×ª×××Ÿ ×‘×›×œ ××§×•×!</strong><br>';
                }
                feedback += '×ª× ××™× ××™×“×™××œ×™×™× ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥ - ××’×¨×©×™ ×›×“×•×¨×’×œ, ×˜× ×™×¡, ××• ×›×œ ×¤×¢×™×œ×•×ª ××—×¨×ª!';
            }
            // Warm but manageable
            else {
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += 'ğŸŒ¤ï¸ <strong>×¦×¤×•×™ ××–×’ ××•×•×™×¨ × ×¢×™× ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥.</strong><br>';
                } else {
                    feedback += 'ğŸŒ¤ï¸ <strong>××–×’ ××•×•×™×¨ × ×¢×™× ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥.</strong><br>';
                }
                if (temp > 28) {
                    feedback += 'ğŸ’§ ×¨×§ ×–×›×•×¨ ×œ×©×ª×•×ª ××™× ×‘××”×œ×š ×”×¤×¢×™×œ×•×ª.';
                } else {
                    feedback += '×ª× ××™× ×˜×•×‘×™× ×œ×›×œ ×¡×•×’×™ ×”×¤×¢×™×œ×•×™×•×ª!';
                }
            }
            
            return feedback;
        }

        // Weather context for search results with time consideration
        function getWeatherContextForResults(weatherData, facilityType, resultsCount) {
            if (!weatherData) return null;
            
            const { temp, main, cityName, forecastTime, isForecast } = weatherData;
            let context = '';
            
            // Create time-appropriate context
            let timePhrase = '';
            if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                if (isForecast) {
                    timePhrase = ` ×œ${getTimeDisplayName(forecastTime)}`;
                } else {
                    timePhrase = ` (×ª×—×–×™×ª ×¢×‘×•×¨ ${getTimeDisplayName(forecastTime)})`;
                }
            }
            
            // Outdoor facilities
            if (OUTDOOR_FACILITIES.includes(facilityType)) {
                if (main === 'Rain' || main === 'Thunderstorm' || main === 'Snow') {
                    if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                        context = `ğŸŒ§ï¸ <strong>×œ×ª×©×•××ª ×œ×‘×›×:</strong> ×¦×¤×•×™ ×’×©× ×‘${cityName}${timePhrase}. ×”××ª×§× ×™× ×©××¦××ª×™ ×”× ×—×™×¦×•× ×™×™× - ×©×§×œ×• ×œ×—×¤×© ××ª×§×Ÿ ××§×•×¨×” ×‘××§×•×.`;
                    } else {
                        context = `ğŸŒ§ï¸ <strong>×œ×ª×©×•××ª ×œ×‘×›×:</strong> ×™×•×¨×“ ×’×©× ×‘${cityName} ×›×¨×’×¢. ×”××ª×§× ×™× ×©××¦××ª×™ ×”× ×—×™×¦×•× ×™×™× - ×©×§×œ×• ×œ×—×¤×© ××ª×§×Ÿ ××§×•×¨×” ×‘××§×•×.`;
                    }
                } else if (temp > 32) {
                    if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                        context = `ğŸ”¥ <strong>×—×©×•×‘ ×œ×“×¢×ª:</strong> ×¦×¤×•×™ ×—×•× ×§×™×¦×•× ×™ ×‘${cityName}${timePhrase} (${temp}Â°C). ×× ×ª×‘×—×¨×• ×œ×”×ª×××Ÿ ×‘×—×•×¥, ×”×§×¤×™×“×• ×œ×©×ª×•×ª ××™×, ×œ×”×ª×××Ÿ ×‘×©×¢×•×ª ×§×¨×™×¨×•×ª, ×•×œ×”×’×Ÿ ××”×©××©.`;
                    } else {
                        context = `ğŸ”¥ <strong>×—×©×•×‘ ×œ×“×¢×ª:</strong> ×—×•× ×§×™×¦×•× ×™ ×‘${cityName} (${temp}Â°C). ×× ×ª×‘×—×¨×• ×œ×”×ª×××Ÿ ×‘×—×•×¥, ×”×§×¤×™×“×• ×œ×©×ª×•×ª ××™×, ×œ×”×ª×××Ÿ ×‘×©×¢×•×ª ×§×¨×™×¨×•×ª, ×•×œ×”×’×Ÿ ××”×©××©.`;
                    }
                } else if (temp < 10) {
                    if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                        context = `ğŸ¥¶ <strong>×˜×™×¤ ×—×:</strong> ×¦×¤×•×™ ×§×•×¨ ×‘${cityName}${timePhrase} (${temp}Â°C). ×”×§×¤×™×“×• ×œ×”×ª×—×× ×”×™×˜×‘ ×•×œ×”×œ×‘×™×© ×©×›×‘×•×ª ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª ×‘×—×•×¥.`;
                    } else {
                        context = `ğŸ¥¶ <strong>×˜×™×¤ ×—×:</strong> ×§×¨ ×‘${cityName} (${temp}Â°C). ×”×§×¤×™×“×• ×œ×”×ª×—×× ×”×™×˜×‘ ×•×œ×”×œ×‘×™×© ×©×›×‘×•×ª ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª ×‘×—×•×¥.`;
                    }
                } else if (temp >= 18 && temp <= 25) {
                    context = `â˜€ï¸ <strong>×ª× ××™× ××•×©×œ××™×!</strong> ××–×’ ××•×•×™×¨ ××™×“×™××œ×™ ×‘${cityName}${timePhrase} (${temp}Â°C) ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥. ×ª×”× ×•!`;
                } else if (temp > 28) {
                    context = `ğŸŒ¤ï¸ <strong>×ª× ××™× ×˜×•×‘×™×</strong> ×‘${cityName}${timePhrase} (${temp}Â°C). ×–×›×¨×• ×œ×©×ª×•×ª ××™× ×‘××”×œ×š ×”×¤×¢×™×œ×•×ª ×‘×—×•×¥.`;
                }
            } 
            // Indoor facilities
            else {
                if (main === 'Rain' || main === 'Thunderstorm' || main === 'Snow') {
                    if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                        context = `ğŸŒ§ï¸ <strong>×‘×—×™×¨×” ××¦×•×™× ×ª!</strong> ×¢× ×”×’×©× ×”×¦×¤×•×™ ×‘${cityName}${timePhrase}, ××ª×§×Ÿ ××§×•×¨×” ×”×•× ×”×¤×ª×¨×•×Ÿ ×”××•×©×œ×.`;
                    } else {
                        context = `ğŸŒ§ï¸ <strong>×‘×—×™×¨×” ××¦×•×™× ×ª!</strong> ×¢× ×”×’×©× ×‘×—×•×¥ ×‘${cityName}, ××ª×§×Ÿ ××§×•×¨×” ×”×•× ×”×¤×ª×¨×•×Ÿ ×”××•×©×œ×.`;
                    }
                } else if (temp > 32) {
                    if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                        context = `ğŸ”¥ <strong>×‘×—×™×¨×” ×—×›××”!</strong> ×¢× ×”×—×•× ×”×§×™×¦×•× ×™ ×”×¦×¤×•×™ ×‘${cityName}${timePhrase} (${temp}Â°C), ××ª×§×Ÿ ××§×•×¨×” ×××•×–×’ ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×•×—.`;
                    } else {
                        context = `ğŸ”¥ <strong>×‘×—×™×¨×” ×—×›××”!</strong> ×¢× ×”×—×•× ×”×§×™×¦×•× ×™ ×‘${cityName} (${temp}Â°C), ××ª×§×Ÿ ××§×•×¨×” ×××•×–×’ ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×•×—.`;
                    }
                } else if (temp >= 18 && temp <= 25) {
                    context = `â˜€ï¸ <strong>×’××™×©×•×ª ××œ××”!</strong> ××–×’ ××•×•×™×¨ ××•×©×œ× ×‘${cityName}${timePhrase}, ××‘×œ ××ª×§×Ÿ ××§×•×¨×” × ×•×ª×Ÿ ×œ×›× ×‘×§×¨×” ××œ××” ×¢×œ ×ª× ××™ ×”×”×ª××× ×•×ª.`;
                }
            }
            
            return context;
        }

        // Context-aware weather feedback for indoor facilities with time consideration
        function getContextualWeatherFeedbackForIndoor(weatherData, facilityType) {
            if (!weatherData) return null;
            
            const { temp, main, description, cityName, forecastTime, isForecast } = weatherData;
            
            // Create time-appropriate message header
            let timeContext = '';
            if (isForecast) {
                timeContext = ` ×œ${getTimeDisplayName(forecastTime)}`;
            } else if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                timeContext = ` (×¢×‘×•×¨ ${getTimeDisplayName(forecastTime)})`;
            }
            
            let feedback = `ğŸŒ¤ï¸ <strong>××–×’ ×”××•×•×™×¨ ×‘${cityName}${timeContext}:</strong> ${temp}Â°C, ${description}<br><br>`;
            
            // Provide context based on weather even for indoor activities
            if (main === 'Rain' || main === 'Thunderstorm' || main === 'Snow') {
                feedback += 'ğŸŒ§ï¸ <strong>×‘×—×™×¨×” ××¦×•×™× ×ª!</strong> ';
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += '×¢× ×”×’×©× ×”×¦×¤×•×™ ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×”×•× ×”×¤×ª×¨×•×Ÿ ×”××•×©×œ×. ';
                } else {
                    feedback += '×¢× ×”×’×©× ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×”×•× ×”×¤×ª×¨×•×Ÿ ×”××•×©×œ×. ';
                }
                
                if (facilityType === '×‘×¨×™×›×”') {
                    feedback += '×‘×¨×™×›×” ××§×•×¨×” ×ª××¤×©×¨ ×œ×š ×œ×©×—×•×ª ×‘× ×•×—×•×ª ×’× ×›×©×™×•×¨×“ ×’×©×!';
                } else {
                    feedback += '××•×œ× ×¡×¤×•×¨×˜ ××§×•×¨×” ×™××¤×©×¨ ×œ×š ×œ×”×ª×××Ÿ ×‘× ×•×—×•×ª ×œ××¨×•×ª ××–×’ ×”××•×•×™×¨!';
                }
            }
            else if (temp > 32) {
                feedback += 'ğŸ”¥ <strong>×‘×—×™×¨×” ×—×›××”!</strong> ';
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += '×¢× ×”×—×•× ×”×§×™×¦×•× ×™ ×”×¦×¤×•×™ ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×¢× ××™×–×•×’ ××•×•×™×¨ ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×•×—. ';
                } else {
                    feedback += '×¢× ×”×—×•× ×”×§×™×¦×•× ×™ ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×¢× ××™×–×•×’ ××•×•×™×¨ ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×•×—. ';
                }
                
                if (facilityType === '×‘×¨×™×›×”') {
                    feedback += '×‘×¨×™×›×” ××§×•×¨×” ×ª××¤×©×¨ ×œ×š ×œ×”×ª×¨×¢× ×Ÿ ×•×œ×”×ª×××Ÿ ×‘×§×¨×™×¨×•×ª!';
                } else {
                    feedback += '××•×œ× ×¡×¤×•×¨×˜ ×××•×–×’ ×™××¤×©×¨ ×œ×š ×œ×”×ª×××Ÿ ×‘× ×•×—×•×ª!';
                }
            }
            else if (temp < 10) {
                feedback += 'ğŸ¥¶ <strong>×‘×—×™×¨×” × ×‘×•× ×”!</strong> ';
                if (forecastTime && forecastTime !== '×¢×›×©×™×•') {
                    feedback += '×¢× ×”×§×•×¨ ×”×¦×¤×•×™ ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×•×—××™× ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×¢×™× ×œ×”×ª×××Ÿ ×‘×•.';
                } else {
                    feedback += '×¢× ×”×§×•×¨ ×‘×—×•×¥, ××ª×§×Ÿ ××§×•×¨×” ×•×—××™× ×™×”×™×” ×”×¨×‘×” ×™×•×ª×¨ × ×¢×™× ×œ×”×ª×××Ÿ ×‘×•.';
                }
            }
            else if (temp >= 18 && temp <= 25) {
                feedback += 'â˜€ï¸ <strong>××–×’ ××•×•×™×¨ ××•×©×œ× ×‘×—×•×¥</strong>, ××‘×œ ××ª×§×Ÿ ××§×•×¨×” ×™×ª×Ÿ ×œ×š ×’××™×©×•×ª ×œ× ×œ×”×™×•×ª ×ª×œ×•×™ ×‘××–×’ ×”××•×•×™×¨. ';
                if (facilityType === '×‘×¨×™×›×”') {
                    feedback += '×‘×¨×™×›×” ×ª×”×™×” × ×”×“×¨×ª ×‘×›×œ ××–×’ ××•×•×™×¨!';
                } else {
                    feedback += '×ª×•×›×œ ×œ×”×ª×××Ÿ ×‘× ×•×—×•×ª ×‘×›×œ ×ª× ××™ ××–×’ ×”××•×•×™×¨!';
                }
            }
            else {
                feedback += 'ğŸŒ¤ï¸ <strong>××–×’ ××•×•×™×¨ × ×¢×™×</strong>, ××‘×œ ××ª×§×Ÿ ××§×•×¨×” × ×•×ª×Ÿ ×™×¦×™×‘×•×ª ×•×‘×§×¨×” ×¢×œ ×ª× ××™ ×”×”×ª××× ×•×ª.';
            }
            
            return feedback;
        }

        // Enhanced weather-based recommendations
        function getWeatherRecommendation(weatherData, facilityType) {
            if (!weatherData || !OUTDOOR_FACILITIES.includes(facilityType)) {
                return null;
            }
            
            const { temp, main, description } = weatherData;
            let recommendation = '';
            let suggestIndoor = false;
            let precautions = [];
            
            // Rain/Storm conditions
            if (main === 'Rain' || main === 'Thunderstorm' || main === 'Snow') {
                recommendation = `ğŸŒ§ï¸ ×›×¨×’×¢ ×™×•×¨×“ ×’×©× ×‘${weatherData.cityName} - <strong>×œ× ××•××œ×¥</strong> ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥!`;
                suggestIndoor = true;
            }
            // Extreme heat
            else if (temp > 32) {
                recommendation = `ğŸ”¥ <strong>××–×”×¨×”: ×—×•× ×§×™×¦×•× ×™</strong> ×‘${weatherData.cityName} (${temp}Â°C)!`;
                precautions = [
                    'ğŸ’§ ×©×ª×• ×”×¨×‘×” ××™× ×œ×¤× ×™, ×‘××”×œ×š ×•××—×¨×™ ×”×¤×¢×™×œ×•×ª',
                    'ğŸ§´ ×”×©×ª××©×• ×‘×§×¨× ×”×’× ×” ×—×–×§',
                    'ğŸ‘• ×œ×‘×©×• ×‘×’×“×™× ×‘×”×™×¨×™× ×•× ×•×©××™×',
                    'â° ×”×¢×“×™×¤×• ×©×¢×•×ª ××•×§×“××•×ª ××• ×××•×—×¨×•×ª'
                ];
                suggestIndoor = true;
            }
            // Very cold
            else if (temp < 5) {
                recommendation = `ğŸ¥¶ ×§×¨ ×××•×“ ×‘×—×•×¥ ×‘${weatherData.cityName} (${temp}Â°C)`;
                precautions = [
                    'ğŸ§¥ ×”×œ×‘×™×©×• ×©×›×‘×•×ª ×—××•×ª',
                    'ğŸ§¤ ××œ ×ª×©×›×—×• ×›×¤×¤×•×ª ×•×›×•×‘×¢',
                    'ğŸƒâ€â™‚ï¸ ×”×ª×—×××• ×”×™×˜×‘ ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª'
                ];
                suggestIndoor = true;
            }
            // Cold but manageable
            else if (temp < 15) {
                recommendation = `ğŸŒ¡ï¸ ×§×¨×™×¨ ×‘×—×•×¥ ×‘${weatherData.cityName} (${temp}Â°C)`;
                precautions = [
                    'ğŸ§¥ ×”×‘×™××• ×©×›×‘×ª ×‘×™×’×•×“ × ×•×¡×¤×ª',
                    'ğŸƒâ€â™‚ï¸ ×”×ª×—×××• ×”×™×˜×‘ ×œ×¤× ×™ ×”×¤×¢×™×œ×•×ª'
                ];
            }
            // Perfect weather
            else if (temp >= 18 && temp <= 25) {
                recommendation = `â˜€ï¸ ××–×’ ××•×•×™×¨ ××•×©×œ× ×‘${weatherData.cityName} (${temp}Â°C) - ××™×“×™××œ×™ ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥!`;
            }
            // Warm but good
            else {
                recommendation = `ğŸŒ¤ï¸ ××–×’ ××•×•×™×¨ × ×¢×™× ×‘${weatherData.cityName} (${temp}Â°C) - ×˜×•×‘ ×œ×¤×¢×™×œ×•×ª ×‘×—×•×¥`;
                if (temp > 28) {
                    precautions = ['ğŸ’§ ×”×§×¤×™×“×• ×œ×©×ª×•×ª ××™×'];
                }
            }
            
            return { recommendation, suggestIndoor, precautions };
        }

        // Enhanced JSON loading
        async function loadSportsData() {
            try {
                updateStatusBadge('×˜×•×¢×Ÿ × ×ª×•× ×™×...');
                
                const possibleUrls = [
                    './sports_facilities.json',
                    './facilities.json',
                    './data.json'
                ];
                
                for (const url of possibleUrls) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (Array.isArray(data) && data.length > 0 && data[0]['×™×©×•×‘']) {
                                sportsData = data;
                                dataSource = url;
                                isDataLoaded = true;
                                updateStatusBadge(`${sportsData.length} ××ª×§× ×™×`);
                                showSuccessMessage();
                                enableInterface();
                                return;
                            }
                        }
                    } catch (fetchError) {
                        console.log(`âŒ ${url} - ${fetchError.message}`);
                    }
                }
                
                loadFallbackData();
            } catch (error) {
                loadFallbackData();
            }
        }

        function loadFallbackData() {
            sportsData = [
                {
                    "×™×©×•×‘": "×ª×œ ××‘×™×‘-×™×¤×•",
                    "×¡×•×’ ××ª×§×Ÿ": "××•×œ× ×¡×¤×•×¨×˜ ×§×˜×Ÿ â€“ 15x24 ×'",
                    "×©× ×”××ª×§×Ÿ": "×‘×™×ª ×”×¦×•×¨×™ - ×“×•×’××”",
                    "×©×›×•× ×”-×¨×•×‘×¢": "××¨×›×– ×”×¢×™×¨",
                    "×¨×—×•×‘": "×”×¦×•×¨×™",
                    "××¡×¤×¨ ×‘×™×ª": 1,
                    "×’×•×£ ××¤×¢×™×œ ×”××ª×§×Ÿ": "×¢×™×¨×™×™×ª ×ª×œ ××‘×™×‘-×™×¤×•",
                    "×˜×œ×¤×•×Ÿ ××™×© ×§×©×¨": "03-1234567",
                    "×¤× ×•×™ ×œ×¤×¢×™×œ×•×ª": "×‘×ª×™××•× ×‘×œ×‘×“",
                    "×ª××•×¨×” ×§×™×™××ª": "×›×Ÿ",
                    "× ×’×™×©×•×ª ×œ× ×›×™×": "×›×Ÿ",
                    "×—× ×™×” ×œ×¨×›×‘×™×": "×›×Ÿ",
                    "××¦×‘ ×”××ª×§×Ÿ": "×ª×§×™×Ÿ ×•×¤×¢×™×œ"
                }
            ];
            
            dataSource = 'fallback';
            isDataLoaded = true;
            updateStatusBadge(`${sportsData.length} ×“×•×’××”`);
            showFallbackMessage();
            enableInterface();
        }

        function updateStatusBadge(text) {
            document.getElementById('statusBadge').textContent = text;
        }

        function enableInterface() {
            document.getElementById('messageInput').disabled = false;
            document.getElementById('sendButton').disabled = false;
            document.getElementById('messageInput').placeholder = '×›×ª×•×‘ ××” ××ª×” ××—×¤×©...';
        }

        function showSuccessMessage() {
            const loadingMsg = document.getElementById('loadingMessage');
            if (loadingMsg) {
                loadingMsg.innerHTML = `
                    âœ… <strong>×©×œ×•×! ××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×”×™×•×?</strong><br><br>
                    ×× ×™ ×›××Ÿ ×›×“×™ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª ××ª×§×Ÿ ×”×¡×¤×•×¨×˜ ×”××•×©×œ× ×‘×™×©×¨××œ.
                `;
            }
        }

        function showFallbackMessage() {
            const loadingMsg = document.getElementById('loadingMessage');
            if (loadingMsg) {
                loadingMsg.innerHTML = `
                    âš ï¸ <strong>×©×œ×•×! ××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š?</strong><br><br>
                    ×× ×™ ×¢×•×‘×“ ×›×¨×’×¢ ×¢× × ×ª×•× ×™ ×“×•×’××”.<br><br>
                    ğŸ’¡ <strong>×›×“×™ ×œ×”×©×ª××© ×‘× ×ª×•× ×™× ×”××œ××™×:</strong><br>
                    1. ×©××•×¨ ××ª ×”×§×•×‘×¥ ×›-<code>sports_facilities.json</code><br>
                    2. ×”× ×— ××•×ª×• ×‘××•×ª×” ×ª×™×§×™×™×”<br>
                    3. ×¨×¢× ×Ÿ ××ª ×”×“×£
                `;
            }
        }

        // Enhanced intent recognition
        function recognizeIntent(message) {
            const msgLower = message.toLowerCase();
            
            const smallTalkPatterns = {
                greeting: ['×©×œ×•×', '×”×™×™', '×”×™', '×‘×•×§×¨ ×˜×•×‘', '×¢×¨×‘ ×˜×•×‘'],
                thanks: ['×ª×•×“×”', '×ª×•×“×” ×¨×‘×”', 'thanks'],
                how_are_you: ['××” × ×©××¢', '××™×š ×”×•×œ×š', '××” ×©×œ×•××š', '××™×š ××ª×” ××¨×’×™×©', '××™×š ××ª×”', '××” ×”××¦×‘'],
                what_day: ['××™×–×” ×™×•×', '××” ×”×™×•×', '××” ×”×ª××¨×™×š'],
                capabilities: ['××” ××ª×” ×™×›×•×œ', '××™ ××ª×”', '××” ××ª×” ×¢×•×©×”'],
                weather_specific: ['××” ××–×’ ×”××•×•×™×¨', '××™×š ××–×’ ×”××•×•×™×¨', '××–×’ ××•×•×™×¨', '××–×’ ×”××•×•×™×¨ ×”×™×•×', '××™×š ××–×’ ×”××•×•×™×¨ ×”×™×•×'],
                off_topic: ['×¤×•×œ×™×˜×™×§×”', '×‘×—×™×¨×•×ª', '×›×œ×›×œ×”', '×—×“×©×•×ª'],
                show_more: ['×¢×•×“', '×”×¦×’ ×¢×•×“', '×¢×•×“ ××ª×§× ×™×', '×”××©×š', '×™×•×ª×¨']
            };
            
            for (const [intent, patterns] of Object.entries(smallTalkPatterns)) {
                if (patterns.some(pattern => msgLower.includes(pattern))) {
                    return intent;
                }
            }
            
            const searchPatterns = ['××—×¤×©', '×¨×•×¦×”', '×× ×™ ×¨×•×¦×”', '×¦×¨×™×š', '××™×¤×”', '×œ××¦×•×'];
            const facilityPatterns = ['××•×œ×', '×‘×¨×™×›×”', '××’×¨×©', '×¡×¤×•×¨×˜', '×›×“×•×¨×’×œ', '×˜× ×™×¡'];
            
            if (searchPatterns.some(p => msgLower.includes(p)) || 
                facilityPatterns.some(p => msgLower.includes(p))) {
                return 'search_facility';
            }
            
            return 'search_facility';
        }

        async function handleSmallTalk(intent, message) {
            const responses = {
                greeting: '×©×œ×•× ×•×‘×¨×›×”! ğŸ˜Š ××™×š ××¤×©×¨ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª×§×Ÿ ×¡×¤×•×¨×˜ ×”×™×•×?',
                thanks: '×ª××™×“ ×‘×©××—×”! ğŸ™Œ ×× ×™ ×›××Ÿ ×× ×ª×¦×˜×¨×š ××ª×§×Ÿ ×¡×¤×•×¨×˜ ×›×œ×©×”×•.',
                how_are_you: '×”×›×œ ××¦×•×™×Ÿ, ×ª×•×“×” ×©×©××œ×ª! ğŸ˜Š ××•×›×Ÿ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª×§×Ÿ ×¡×¤×•×¨×˜ × ×”×“×¨!',
                what_day: `×”×™×•× ${getCurrentDate()} ğŸ“… ×™×•× × ×”×“×¨ ×œ×¤×¢×™×œ×•×ª ×¡×¤×•×¨×˜! ×¨×•×¦×” ×©×××¦× ×œ×š ××ª×§×Ÿ?`,
                capabilities: '×× ×™ ×¦\'××˜ ×‘×•×˜ ×©××ª××—×” ×‘×¢×–×¨×” ×¢× ××ª×§× ×™ ×¡×¤×•×¨×˜ ×‘×™×©×¨××œ ğŸ¤¸â€â™‚ï¸<br>×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª×§× ×™× ×•×œ×‘×“×•×§ ××–×’ ××•×•×™×¨!',
                off_topic: '×–×” ×œ× ×‘×ª×—×•× ×”×”×ª××—×•×ª ×©×œ×™, ××‘×œ ×× ×™ ×›××Ÿ ×›×“×™ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª×§× ×™ ×¡×¤×•×¨×˜ ×‘×™×©×¨××œ! ğŸ˜Š'
            };
            
            // Handle weather-specific queries
            if (intent === 'weather_specific') {
                const location = findLocationInData(message);
                const timeFromMessage = extractTimeFromMessage(message) || '×¢×›×©×™×•';
                
                if (location) {
                    let weatherMessage = '×¨×’×¢ ××—×“, ×‘×•×“×§ ××ª ××–×’ ×”××•×•×™×¨';
                    if (timeFromMessage !== '×¢×›×©×™×•') {
                        weatherMessage += ` ×‘${location} ×œ${getTimeDisplayName(timeFromMessage)}`;
                    } else {
                        weatherMessage += ` ×‘${location}`;
                    }
                    weatherMessage += '... ğŸŒ¤ï¸';
                    
                    addMessage(weatherMessage, 'bot');
                    showTypingIndicator();
                    
                    const weatherData = await getWeatherDataForTime(location, timeFromMessage);
                    hideTypingIndicator();
                    
                    if (weatherData) {
                        const weatherMessage = getContextualWeatherFeedback(weatherData);
                        addMessage(weatherMessage, 'bot');
                    } else {
                        addMessage(`××¦×˜×¢×¨, ×œ× ×”×¦×œ×—×ª×™ ×œ×§×‘×œ × ×ª×•× ×™ ××–×’ ××•×•×™×¨ ×¢×‘×•×¨ ${location} ×›×¨×’×¢. ğŸ˜•<br><br>ğŸ’¡ <strong>××¤×©×¨×•×™×•×ª:</strong><br>ğŸ”„ × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×›××” ×“×§×•×ª<br>ğŸŒ ×•×“× ×©×™×© ×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜<br>ğŸ“‹ ×‘×“×•×§ ×‘-console ×©×œ ×”×“×¤×“×¤×Ÿ (F12) ×œ×¤×¨×˜×™× × ×•×¡×¤×™×`, 'bot');
                    }
                } else {
                    addMessage('××™×¤×” ××ª×” ×¨×•×¦×” ×œ×‘×“×•×§ ××ª ××–×’ ×”××•×•×™×¨? ğŸŒ¤ï¸<br><br>ğŸ’¬ ×œ×“×•×’××”: "××” ××–×’ ×”××•×•×™×¨ ×‘×ª×œ ××‘×™×‘?"', 'bot');
                }
                return null;
            }
            
            return responses[intent] || '××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×”×™×•×? ğŸ˜Š';
        }

        function findLocationInData(message) {
            if (!sportsData || sportsData.length === 0) return null;
            
            const msgLower = message.toLowerCase();
            const settlements = [...new Set(sportsData.map(f => f['×™×©×•×‘']).filter(Boolean))];
            
            // Try to find location in data
            for (const settlement of settlements) {
                if (msgLower.includes(settlement.toLowerCase())) {
                    return settlement;
                }
            }
            
            // Enhanced city patterns with English names for weather API
            const cityPatterns = {
                '×ª×œ ××‘×™×‘-×™×¤×•': ['×ª×œ ××‘×™×‘', '×ª×', 'tel aviv'],
                '×™×¨×•×©×œ×™×': ['×™×¨×•×©×œ×™×', 'jerusalem'],
                '×—×™×¤×”': ['×—×™×¤×”', 'haifa'],
                '×‘××¨ ×©×‘×¢': ['×‘××¨ ×©×‘×¢', 'beer sheva'],
                '×¤×ª×— ×ª×§×•×•×”': ['×¤×ª×— ×ª×§×•×•×”', 'petah tikva'],
                '× ×ª× ×™×”': ['× ×ª× ×™×”', 'netanya'],
                '××©×“×•×“': ['××©×“×•×“', 'ashdod'],
                '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ': ['×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ', 'rishon lezion'],
                '×—×•×œ×•×Ÿ': ['×—×•×œ×•×Ÿ', 'holon'],
                '×¨×—×•×‘×•×ª': ['×¨×—×•×‘×•×ª', 'rehovot']
            };
            
            for (const [city, patterns] of Object.entries(cityPatterns)) {
                if (patterns.some(pattern => msgLower.includes(pattern))) {
                    return city;
                }
            }
            
            return null;
        }

        // Convert Hebrew city names to English for weather API
        function getEnglishCityName(hebrewCity) {
            const cityTranslations = {
                '×ª×œ ××‘×™×‘-×™×¤×•': 'Tel Aviv',
                '×ª×œ ××‘×™×‘': 'Tel Aviv',
                '×™×¨×•×©×œ×™×': 'Jerusalem',
                '×—×™×¤×”': 'Haifa',
                '×‘××¨ ×©×‘×¢': 'Beer Sheva',
                '×¤×ª×— ×ª×§×•×•×”': 'Petah Tikva',
                '× ×ª× ×™×”': 'Netanya',
                '××©×“×•×“': 'Ashdod',
                '×¨××©×•×Ÿ ×œ×¦×™×•×Ÿ': 'Rishon LeZion',
                '×—×•×œ×•×Ÿ': 'Holon',
                '×¨×—×•×‘×•×ª': 'Rehovot'
            };
            
            return cityTranslations[hebrewCity] || hebrewCity;
        }

        function findFacilityTypeInData(message) {
            const msgLower = message.toLowerCase();
            
            const searchPatterns = [
                { patterns: ['×‘×¨×™×›', '×©×—×™×™', '×©×—×™×”'], match: '×‘×¨×™×›×”' },
                { patterns: ['××•×œ×', '×”×ª×¢××œ×•×ª'], match: '××•×œ×' },
                { patterns: ['×›×“×•×¨×’×œ', '×“×©×'], match: '×›×“×•×¨×’×œ' },
                { patterns: ['×›×“×•×¨×¡×œ'], match: '×›×“×•×¨×¡×œ' },
                { patterns: ['×˜× ×™×¡'], match: '×˜× ×™×¡' },
                { patterns: ['×›×“×•×¨×¢×£', '×—×•×œ'], match: '×›×“×•×¨×¢×£' },
                { patterns: ['×›×•×©×¨', '×¤×™×˜× ×¡'], match: '×›×•×©×¨' }
            ];
            
            for (const { patterns, match } of searchPatterns) {
                if (patterns.some(pattern => msgLower.includes(pattern))) {
                    return match;
                }
            }
            
            return null;
        }

        // Comprehensive information extraction for first messages
        function extractAllAvailableInfo(message) {
            const msgLower = message.toLowerCase();
            console.log('ğŸ” Comprehensive extraction from:', msgLower);
            
            const extractedInfo = {
                facility_type: null,
                location: null,
                time: null,
                accessibility: null,
                parking: null,
                lighting: null
            };
            
            // Extract facility type using enhanced keyword matching
            extractedInfo.facility_type = findFacilityTypeInData(message);
            
            // Extract location
            extractedInfo.location = findLocationInData(message);
            
            // Extract time with enhanced patterns
            extractedInfo.time = extractTimeFromMessage(message);
            
            // Extract accessibility needs - be more liberal in first message
            if (msgLower.includes('× ×’×™×©') || msgLower.includes('××•×’×‘×œ') || 
                msgLower.includes('×›×™×¡× ×’×œ×’×œ') || msgLower.includes('× ×›×™×')) {
                extractedInfo.accessibility = '×›×Ÿ';
            } else if (msgLower.includes('×œ× × ×’×™×©') || msgLower.includes('×‘×œ×™ × ×’×™×©')) {
                extractedInfo.accessibility = '×œ×';
            }
            
            // Extract parking needs
            if (msgLower.includes('×—× ×™') || msgLower.includes('×¨×›×‘') || 
                msgLower.includes('××§×•× ×—× ×™×”') || msgLower.includes('×¤××¨×§×™× ×’')) {
                extractedInfo.parking = '×›×Ÿ';
            } else if (msgLower.includes('×‘×œ×™ ×—× ×™') || msgLower.includes('×œ× ×—× ×™')) {
                extractedInfo.parking = '×œ×';
            }
            
            // Extract lighting needs
            if (msgLower.includes('×ª××•×¨') || msgLower.includes('××•×¨') || 
                msgLower.includes('×œ×™×œ×”') || msgLower.includes('×‘×—×•×©×š') ||
                msgLower.includes('××•××¨')) {
                extractedInfo.lighting = '×›×Ÿ';
            } else if (msgLower.includes('×‘×œ×™ ×ª××•×¨') || msgLower.includes('×œ× ×ª××•×¨')) {
                extractedInfo.lighting = '×œ×';
            }
            
            // Enhanced context detection for implicit requests
            
            // Detect implicit facility requests
            if (!extractedInfo.facility_type) {
                // Look for sport activity mentions that imply facility types
                if (msgLower.includes('×œ×©×—×•×ª') || msgLower.includes('×©×—×™×™×”')) {
                    extractedInfo.facility_type = '×‘×¨×™×›×ª ×©×—×™×™×” (50X20)';
                } else if (msgLower.includes('×œ×¨×•×¥') || msgLower.includes('×¨×™×¦×”') || msgLower.includes('×’\'×•×’×™× ×’')) {
                    extractedInfo.facility_type = '××¡×œ×•×œ ××ª×œ×˜×™×§×” ×§×œ×”';
                } else if (msgLower.includes('×œ×”×ª×××Ÿ') && !extractedInfo.facility_type) {
                    extractedInfo.facility_type = '××•×œ× ×¡×¤×•×¨×˜ ×‘×™× ×•× ×™';
                }
            }
            
            // Detect implicit time requests
            if (!extractedInfo.time) {
                if (msgLower.includes('×“×—×•×£') || msgLower.includes('××™×™×“×™') || msgLower.includes('××”×¨')) {
                    extractedInfo.time = '×¢×›×©×™×•';
                } else if (msgLower.includes('×©×‘×ª') || msgLower.includes('×¡×•×¤"×©') || msgLower.includes('×¡×•×£ ×”×©×‘×•×¢')) {
                    extractedInfo.time = '×¡×•×£ ×”×©×‘×•×¢';
                }
            }
            
            console.log('ğŸ“ Comprehensive extraction results:', extractedInfo);
            return extractedInfo;
        }

        function extractEntities(message) {
            const msgLower = message.toLowerCase();
            
            // Extract basic entities for follow-up messages
            const entities = {};
            
            // Only extract if not already set - avoid overriding first message extractions
            if (!conversationState.slots.facility_type) {
                entities.facility_type = findFacilityTypeInData(message);
            }
            
            if (!conversationState.slots.location) {
                entities.location = findLocationInData(message);
            }
            
            // Extract time entities
            if (!conversationState.slots.time) {
                const timeEntity = extractTimeFromMessage(message);
                if (timeEntity) {
                    entities.time = timeEntity;
                }
            }
            
            // Extract yes/no responses based on conversation flow
            const isYesResponse = msgLower.includes('×›×Ÿ') || msgLower.includes('yes') || 
                                msgLower.includes('×‘×•×•×“××™') || msgLower.includes('×—×©×•×‘ ×œ×™');
            const isNoResponse = msgLower.includes('×œ×') || msgLower.includes('no') || 
                               msgLower.includes('×œ× ×—×©×•×‘') || msgLower.includes('×‘×œ×™');
            
            // Extract accessibility needs
            if (msgLower.includes('× ×’×™×©') || msgLower.includes('××•×’×‘×œ') || msgLower.includes('×›×™×¡× ×’×œ×’×œ')) {
                entities.accessibility = '×›×Ÿ';
            } else if (msgLower.includes('×œ× × ×’×™×©') || msgLower.includes('×‘×œ×™ × ×’×™×©')) {
                entities.accessibility = '×œ×';
            } else if (conversationState.slots.accessibility === null) {
                if (isYesResponse) entities.accessibility = '×›×Ÿ';
                if (isNoResponse) entities.accessibility = '×œ×';
            }
            
            // Extract parking needs - only if accessibility is already set
            if (msgLower.includes('×—× ×™') || msgLower.includes('×¨×›×‘')) {
                entities.parking = '×›×Ÿ';
            } else if (msgLower.includes('×‘×œ×™ ×—× ×™') || msgLower.includes('×œ× ×—× ×™')) {
                entities.parking = '×œ×';
            } else if (conversationState.slots.parking === null && conversationState.slots.accessibility !== null) {
                if (isYesResponse) entities.parking = '×›×Ÿ';
                if (isNoResponse) entities.parking = '×œ×';
            }
            
            // Extract lighting needs - only if parking is already set
            if (msgLower.includes('×ª××•×¨') || msgLower.includes('××•×¨') || msgLower.includes('×œ×™×œ×”')) {
                entities.lighting = '×›×Ÿ';
            } else if (msgLower.includes('×‘×œ×™ ×ª××•×¨') || msgLower.includes('×œ× ×ª××•×¨')) {
                entities.lighting = '×œ×';
            } else if (conversationState.slots.lighting === null && conversationState.slots.parking !== null) {
                if (isYesResponse) entities.lighting = '×›×Ÿ';
                if (isNoResponse) entities.lighting = '×œ×';
            }
            
            return entities;
        }

        // Extract time information from user message - Enhanced for first messages
        function extractTimeFromMessage(message) {
            const msgLower = message.toLowerCase();
            
            // Enhanced time patterns in Hebrew for first messages
            const timePatterns = {
                '×¢×›×©×™×•': '×¢×›×©×™×•',
                '×›×¢×ª': '×¢×›×©×™×•', 
                '×¢×›×¡×™×•': '×¢×›×©×™×•',
                '××™×™×“×™': '×¢×›×©×™×•',
                '×“×—×•×£': '×¢×›×©×™×•',
                '××”×¨': '×¢×›×©×™×•',
                '×”×™×•×': '×”×™×•×',
                '×”×œ×™×œ×”': '×œ×™×œ×”',
                '×”×¢×¨×‘': '×¢×¨×‘',
                '×”×‘×•×§×¨': '×‘×•×§×¨',
                '××—×¨': '××—×¨',
                '××—×¨×ª×™×™×': '××—×¨×ª×™×™×',
                '×‘×¢×¨×‘': '×¢×¨×‘',
                '×‘×‘×•×§×¨': '×‘×•×§×¨',
                '×‘×¦×”×¨×™×™×': '×¦×”×¨×™×™×',
                '××—×¨ ×”×¦×”×¨×™×™×': '××—×¨ ×”×¦×”×¨×™×™×',
                '××—×¨×™ ×”×¦×”×¨×™×™×': '××—×¨ ×”×¦×”×¨×™×™×',
                '×‘×œ×™×œ×”': '×œ×™×œ×”',
                '×”×©×‘×•×¢': '×”×©×‘×•×¢',
                '×¡×•×£ ×”×©×‘×•×¢': '×¡×•×£ ×”×©×‘×•×¢',
                '×¡×•×¤"×©': '×¡×•×£ ×”×©×‘×•×¢',
                '×‘×¡×•×¤"×©': '×¡×•×£ ×”×©×‘×•×¢',
                '×©×‘×ª': '×¡×•×£ ×”×©×‘×•×¢',
                '×‘×©×‘×ª': '×¡×•×£ ×”×©×‘×•×¢',
                '×™×•× ×©×™×©×™': '×¡×•×£ ×”×©×‘×•×¢',
                '×™×•× ×©×‘×ª': '×¡×•×£ ×”×©×‘×•×¢',
                '×‘×¢×•×“ ×©×¢×”': '×‘×¢×•×“ ×©×¢×”',
                '×‘×¢×•×“ ×©×¢×ª×™×™×': '×‘×¢×•×“ ×©×¢×ª×™×™×',
                '×ª×•×š ×›×“×™': '×¢×›×©×™×•',
                '×›×¨×’×¢': '×¢×›×©×™×•',
                '×‘××”×œ×š ×”×™×•×': '×”×™×•×',
                '×‘××”×œ×š ×”×¢×¨×‘': '×¢×¨×‘',
                '×œ××—×¨': '××—×¨',
                '×œ××—×¨×ª': '××—×¨'
            };
            
            // Check for specific time patterns
            for (const [pattern, normalized] of Object.entries(timePatterns)) {
                if (msgLower.includes(pattern)) {
                    console.log('â° Found time pattern:', pattern, 'â†’', normalized);
                    return normalized;
                }
            }
            
            // Check for hour patterns (e.g., "×‘-8", "×‘×©×¢×” 10", "×‘8 ×‘×‘×•×§×¨")
            const hourMatches = msgLower.match(/(?:×‘×©×¢×”|×‘[Ö¾\-]?)(\d{1,2})/);
            if (hourMatches) {
                const hour = parseInt(hourMatches[1]);
                if (hour >= 6 && hour <= 11) return '×‘×•×§×¨';
                if (hour >= 12 && hour <= 17) return '×¦×”×¨×™×™×';
                if (hour >= 18 && hour <= 22) return '×¢×¨×‘';
                if (hour >= 23 || hour <= 5) return '×œ×™×œ×”';
            }
            
            // Check for day-specific patterns
            const dayPatterns = [
                { pattern: /×‘×™×•× ×¨××©×•×Ÿ|×™×•× ×¨××©×•×Ÿ/i, value: '×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×©× ×™|×™×•× ×©× ×™/i, value: '×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×©×œ×™×©×™|×™×•× ×©×œ×™×©×™/i, value: '×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×¨×‘×™×¢×™|×™×•× ×¨×‘×™×¢×™/i, value: '×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×—××™×©×™|×™×•× ×—××™×©×™/i, value: '×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×©×™×©×™|×™×•× ×©×™×©×™/i, value: '×¡×•×£ ×”×©×‘×•×¢' },
                { pattern: /×‘×™×•× ×©×‘×ª|×™×•× ×©×‘×ª/i, value: '×¡×•×£ ×”×©×‘×•×¢' }
            ];
            
            for (const dayPattern of dayPatterns) {
                if (dayPattern.pattern.test(message)) {
                    console.log('ğŸ“… Found day pattern:', dayPattern.value);
                    return dayPattern.value;
                }
            }
            
            return null;
        }

        function updateSlots(entities) {
            for (const [key, value] of Object.entries(entities)) {
                if (value && conversationState.slots[key] === null) {
                    conversationState.slots[key] = value;
                }
            }
        }

        function getMissingSlots() {
            const required = ['location', 'facility_type', 'time', 'accessibility', 'parking', 'lighting'];
            return required.filter(slot => conversationState.slots[slot] === null);
        }

        function askForMissingInfo(missingSlots) {
            if (missingSlots.includes('location')) {
                return '×‘××™×–×” ×¢×™×¨ ××• ×™×™×©×•×‘ ××ª×” ××¢×•× ×™×™×Ÿ? ğŸ™ï¸';
            }
            if (missingSlots.includes('facility_type')) {
                // Enhanced facility type suggestion with examples
                const availableTypes = getAvailableFacilityTypes();
                let facilityPrompt = '××™×–×” ×¡×•×’ ××ª×§×Ÿ ×¡×¤×•×¨×˜ ××ª×” ××—×¤×©? ğŸƒâ€â™‚ï¸<br><br>';
                
                if (availableTypes.length > 0) {
                    facilityPrompt += 'ğŸ’¡ <strong>×“×•×’×××•×ª ×œ××ª×§× ×™× ×–××™× ×™×:</strong><br>';
                    // Show most common facility types as examples
                    const examples = availableTypes.slice(0, 6);
                    facilityPrompt += examples.map(type => `â€¢ ${type}`).join('<br>');
                    facilityPrompt += '<br><br>ğŸ’¬ ×¤×©×•×˜ ×›×ª×•×‘ ××” ××ª×” ××—×¤×©!';
                }
                
                return facilityPrompt;
            }
            if (missingSlots.includes('time')) {
                return '××ª×™ ××ª×” ×¨×•×¦×” ×œ×”×ª×××Ÿ? â°<br><br>ğŸ’¬ ×œ×“×•×’××”: "×¢×›×©×™×•", "××—×¨ ×‘×‘×•×§×¨", "×”×™×•× ×‘×¢×¨×‘", "×‘×¢×•×“ ×©×¢×”"';
            }
            if (missingSlots.includes('accessibility')) {
                return '×”×× ×™×© ×¦×•×¨×š ×‘× ×’×™×©×•×ª ×œ×× ×©×™× ×¢× ××•×’×‘×œ×•×™×•×ª? (×›×Ÿ/×œ×) â™¿';
            }
            if (missingSlots.includes('parking')) {
                return '×”×× ×—×©×•×‘ ×œ×š ×©×™×”×™×” ×—× ×™×”? (×›×Ÿ/×œ×) ğŸš—';
            }
            if (missingSlots.includes('lighting')) {
                return '×”×× ×™×© ×¦×•×¨×š ×‘×ª××•×¨×”? (×›×Ÿ/×œ×) ğŸ’¡';
            }
            return null;
        }

        function filterFacilities() {
            if (!sportsData || sportsData.length === 0) return [];
            
            return sportsData.filter(facility => {
                // Filter by location
                if (conversationState.slots.location) {
                    const targetLocation = conversationState.slots.location.toLowerCase();
                    const facilityLocation = (facility['×™×©×•×‘'] || '').toLowerCase();
                    if (!facilityLocation.includes(targetLocation)) return false;
                }
                
                // Filter by facility type
                if (conversationState.slots.facility_type) {
                    const targetTypes = FACILITY_MAPPINGS[conversationState.slots.facility_type] || [];
                    const facilityType = (facility['×¡×•×’ ××ª×§×Ÿ'] || '').toLowerCase();
                    
                    const matches = targetTypes.some(type => 
                        facilityType.includes(type.toLowerCase())
                    );
                    
                    if (!matches) return false;
                }
                
                // Filter by time availability
                if (conversationState.slots.time) {
                    const availability = facility['×¤× ×•×™ ×œ×¤×¢×™×œ×•×ª'] || '';
                    const timeCompatible = checkTimeCompatibility(conversationState.slots.time, availability);
                    if (!timeCompatible.compatible) return false;
                }
                
                // Filter by accessibility
                if (conversationState.slots.accessibility === '×›×Ÿ') {
                    const accessibility = (facility['× ×’×™×©×•×ª ×œ× ×›×™×'] || '').toLowerCase();
                    if (!accessibility.includes('×›×Ÿ')) return false;
                }
                
                // Filter by parking
                if (conversationState.slots.parking === '×›×Ÿ') {
                    const parking = (facility['×—× ×™×” ×œ×¨×›×‘×™×'] || '').toLowerCase();
                    if (!parking.includes('×›×Ÿ')) return false;
                }
                
                // Filter by lighting
                if (conversationState.slots.lighting === '×›×Ÿ') {
                    const lighting = (facility['×ª××•×¨×” ×§×™×™××ª'] || '').toLowerCase();
                    if (!lighting.includes('×›×Ÿ')) return false;
                }
                
                return true;
            });
        }

        // Check if requested time is compatible with facility availability
        function checkTimeCompatibility(requestedTime, facilityAvailability) {
            const availability = facilityAvailability.toLowerCase();
            
            // Handle "×‘×ª×™××•× ×‘×œ×‘×“" or similar appointment-only cases
            if (availability.includes('×‘×ª×™××•×') || availability.includes('×ª×™××•×')) {
                return { 
                    compatible: true, 
                    note: '×–××™×Ÿ ×‘×ª×™××•× ××¨××© ×‘×œ×‘×“' 
                };
            }
            
            // Handle "×¤×ª×•×— ×œ×§×”×œ" - always available
            if (availability.includes('×¤×ª×•×— ×œ×§×”×œ') || availability.includes('×¤×ª×•×—')) {
                return { compatible: true, note: null };
            }
            
            // Handle specific time restrictions
            const timeMap = {
                '×‘×•×§×¨': ['×‘×•×§×¨', '×©×¢×•×ª ×”×‘×•×§×¨', '06:', '07:', '08:', '09:', '10:', '11:'],
                '×¦×”×¨×™×™×': ['×¦×”×¨×™×™×', '××—×¨ ×”×¦×”×¨×™×™×', '12:', '13:', '14:', '15:', '16:', '17:'],
                '×¢×¨×‘': ['×¢×¨×‘', '×©×¢×•×ª ×”×¢×¨×‘', '18:', '19:', '20:', '21:', '22:'],
                '×œ×™×œ×”': ['×œ×™×œ×”', '×©×¢×•×ª ×”×œ×™×œ×”', '23:', '00:', '01:', '02:', '03:', '04:', '05:']
            };
            
            // Check if facility specifies time restrictions
            if (availability.includes('×¨×§') || availability.includes('××—×¨ ×”×¦×”×¨×™×™×') || 
                availability.includes('×‘×•×§×¨') || availability.includes('×¢×¨×‘')) {
                
                const requestedTimeCategory = requestedTime;
                const patterns = timeMap[requestedTimeCategory] || [requestedTimeCategory];
                
                // Check if any pattern matches the facility availability
                const hasMatch = patterns.some(pattern => availability.includes(pattern));
                
                if (!hasMatch) {
                    // Check opposite restrictions
                    if (availability.includes('×¨×§ ×‘×•×§×¨') && ['×¢×¨×‘', '×œ×™×œ×”', '×¦×”×¨×™×™×'].includes(requestedTimeCategory)) {
                        return { 
                            compatible: false, 
                            note: `×”××ª×§×Ÿ ×¤×ª×•×— ×¨×§ ×‘×©×¢×•×ª ×”×‘×•×§×¨, ×œ× ×–××™×Ÿ ${getTimeDisplayName(requestedTimeCategory)}` 
                        };
                    }
                    if (availability.includes('×¨×§ ×¢×¨×‘') && ['×‘×•×§×¨', '×¦×”×¨×™×™×'].includes(requestedTimeCategory)) {
                        return { 
                            compatible: false, 
                            note: `×”××ª×§×Ÿ ×¤×ª×•×— ×¨×§ ×‘×©×¢×•×ª ×”×¢×¨×‘, ×œ× ×–××™×Ÿ ${getTimeDisplayName(requestedTimeCategory)}` 
                        };
                    }
                    if (availability.includes('××—×¨ ×”×¦×”×¨×™×™×') && requestedTimeCategory === '×‘×•×§×¨') {
                        return { 
                            compatible: false, 
                            note: '×”××ª×§×Ÿ ×¤×ª×•×— ×¨×§ ××—×¨ ×”×¦×”×¨×™×™×, ×œ× ×–××™×Ÿ ×‘×‘×•×§×¨' 
                        };
                    }
                }
            }
            
            // Default: assume compatible
            return { compatible: true, note: null };
        }

        function getTimeDisplayName(timeCategory) {
            const names = {
                '×‘×•×§×¨': '×‘×‘×•×§×¨',
                '×¦×”×¨×™×™×': '×‘×¦×”×¨×™×™×', 
                '××—×¨ ×”×¦×”×¨×™×™×': '××—×¨ ×”×¦×”×¨×™×™×',
                '×¢×¨×‘': '×‘×¢×¨×‘',
                '×œ×™×œ×”': '×‘×œ×™×œ×”',
                '×¢×›×©×™×•': '×›×¢×ª',
                '×”×™×•×': '×”×™×•×',
                '××—×¨': '××—×¨',
                '××—×¨×ª×™×™×': '××—×¨×ª×™×™×',
                '×”×©×‘×•×¢': '×”×©×‘×•×¢',
                '×¡×•×£ ×”×©×‘×•×¢': '×‘×¡×•×£ ×”×©×‘×•×¢',
                '×‘×¢×•×“ ×©×¢×”': '×‘×¢×•×“ ×©×¢×”',
                '×‘×¢×•×“ ×©×¢×ª×™×™×': '×‘×¢×•×“ ×©×¢×ª×™×™×'
            };
            return names[timeCategory] || timeCategory;
        }

        // Pagination functions
        function displayPaginatedResults(facilities, startFromBeginning = true) {
            if (startFromBeginning) {
                conversationState.searchResults = facilities;
                conversationState.currentPage = 0;
            }
            
            // For first page: show 3 results. For subsequent pages: show 10 results
            const isFirstPage = conversationState.currentPage === 0;
            const pageSize = isFirstPage ? conversationState.resultsPerPage : conversationState.showMorePerPage;
            
            const startIndex = isFirstPage ? 0 : conversationState.resultsPerPage + (conversationState.currentPage - 1) * conversationState.showMorePerPage;
            const endIndex = startIndex + pageSize;
            const currentPageResults = conversationState.searchResults.slice(startIndex, endIndex);
            
            if (currentPageResults.length === 0) {
                addMessage('×–×” ×›×œ ×”××ª×§× ×™× ×©××¦××ª×™! ğŸ˜Š', 'bot');
                return;
            }
            
            // Show results message only on first page
            if (conversationState.currentPage === 0) {
                const totalResults = conversationState.searchResults.length;
                let resultsMessage = totalResults === 1 ? 
                    'ğŸ¯ ××¦××ª×™ ××ª ×”××ª×§×Ÿ ×”××•×©×œ× ×‘×©×‘×™×œ×š:' :
                    `ğŸ¯ ××¦××ª×™ ${totalResults} ××ª×§× ×™× ×©××ª××™××™× ×œ×‘×§×©×ª×š. ××¦×™×’ ${Math.min(3, totalResults)} ×¨××©×•× ×™×:`;
                addMessage(resultsMessage, 'bot');
            }
            
            // Display current page results
            currentPageResults.forEach((facility, index) => {
                setTimeout(() => {
                    addMessage(createFacilityCard(facility), 'bot');
                }, index * 200);
            });
            
            // Calculate remaining results correctly
            const remainingResults = conversationState.searchResults.length - endIndex;
            
            // Show "more results" button only if there are actually more results
            if (remainingResults > 0) {
                setTimeout(() => {
                    const showMoreButton = `
                        <div class="show-more-btn" onclick="showMoreResults()">
                            ğŸ‘‰ ×”×¦×’ ×¢×•×“ ${Math.min(remainingResults, conversationState.showMorePerPage)} ××ª×§× ×™× ğŸ”
                        </div>
                        <div style="text-align: center; font-size: 12px; color: #666; margin-top: 5px;">
                            ×¢×•×“ ${remainingResults} ××ª×§× ×™× ×–××™× ×™×
                        </div>
                    `;
                    addMessage(showMoreButton, 'bot');
                }, currentPageResults.length * 200 + 500);
            }
            
            conversationState.currentPage++;
        }

        function showMoreResults() {
            displayPaginatedResults(null, false);
        }

        function createFacilityCard(facility) {
            const facilityName = facility['×©× ×”××ª×§×Ÿ'] || '×©× ×œ× ×–××™×Ÿ';
            const facilityType = facility['×¡×•×’ ××ª×§×Ÿ'] || '×¡×•×’ ×œ× ×¦×•×™×Ÿ';
            const city = facility['×™×©×•×‘'] || '×¢×™×¨ ×œ× ×¦×•×™× ×”';
            const phone = facility['×˜×œ×¤×•×Ÿ ××™×© ×§×©×¨'];
            const availability = facility['×¤× ×•×™ ×œ×¤×¢×™×œ×•×ª'] || '×œ× ×¦×•×™×Ÿ';
            
            // Only show phone if it exists and is not "×œ× ×§×™×™×"
            const hasValidPhone = phone && phone !== '×œ× ×§×™×™×' && phone.trim() !== '';
            
            // Check time compatibility for display
            let timeNote = '';
            if (conversationState.slots.time) {
                const timeCheck = checkTimeCompatibility(conversationState.slots.time, availability);
                if (timeCheck.note) {
                    timeNote = `<br>â° ${timeCheck.note}`;
                }
            }
            
            const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(facilityName + ', ' + city)}`;
            
            return `<div class="facility-card">
                <div class="facility-name">${facilityName}</div>
                <div class="facility-type">${facilityType}</div>
                <div class="facility-details">
                    ğŸ“ <strong>${city}</strong><br>
                    ${hasValidPhone ? 'ğŸ“ ' + phone + '<br>' : ''}
                    ğŸ• <strong>×–××™× ×•×ª:</strong> ${availability}${timeNote}
                </div>
                <a href="${googleMapsUrl}" target="_blank" class="facility-link">ğŸ—ºï¸ ××¤×•×ª ×’×•×’×œ</a>
                ${hasValidPhone ? `<a href="tel:${phone}" class="facility-link">ğŸ“ ×”×ª×§×©×¨</a>` : ''}
            </div>`;
        }

        async function processMessage(message) {
            if (!isDataLoaded) {
                addMessage('âš ï¸ × ×ª×•× ×™ ×”××ª×§× ×™× ×¢×“×™×™×Ÿ × ×˜×¢× ×™×. ×× × ×”××ª×Ÿ...', 'bot');
                return;
            }
            
            showTypingIndicator();
            
            try {
                const intent = recognizeIntent(message);
                hideTypingIndicator();
                
                // Handle small talk
                if (['greeting', 'thanks', 'how_are_you', 'what_day', 'capabilities', 'weather_specific', 'off_topic'].includes(intent)) {
                    const response = await handleSmallTalk(intent, message);
                    if (response) {
                        addMessage(response, 'bot');
                    }
                    return;
                }
                
                // Handle show more results
                if (intent === 'show_more') {
                    if (conversationState.searchResults.length > 0) {
                        showMoreResults();
                    } else {
                        addMessage('××™×Ÿ ×¢×•×“ ×ª×•×¦××•×ª ×œ×”×¦×™×’. ×‘×•× × ×—×¤×© ××©×”×• ×—×“×©! ğŸ˜Š', 'bot');
                    }
                    return;
                }
                
                // Handle search facility
                if (intent === 'search_facility') {
                    if (conversationState.intent === null) {
                        conversationState.intent = 'search_facility';
                    }
                    
                    // Smart analysis - extract everything immediately
                    const entities = extractEntities(message);
                    updateSlots(entities);
                    
                    const hasBasicInfo = conversationState.slots.location && conversationState.slots.facility_type;
                    
                    // Weather check for outdoor facilities
                    if (hasBasicInfo && !conversationState.weatherChecked && 
                        OUTDOOR_FACILITIES.includes(conversationState.slots.facility_type)) {
                        
                        addMessage('×¨×’×¢ ××—×“, ×‘×•×“×§ ××ª ××–×’ ×”××•×•×™×¨... ğŸŒ¤ï¸', 'bot');
                        showTypingIndicator();
                        
                        const weatherData = await getWeatherData(conversationState.slots.location);
                        conversationState.weatherData = weatherData;
                        conversationState.weatherChecked = true;
                        
                        hideTypingIndicator();
                        
                        if (weatherData) {
                            // Use BOTH context-aware feedback AND recommendations
                            const contextualFeedback = getContextualWeatherFeedback(weatherData);
                            const weatherRec = getWeatherRecommendation(weatherData, conversationState.slots.facility_type);
                            
                            if (contextualFeedback) {
                                addMessage(contextualFeedback, 'bot');
                            }
                            
                            if (weatherRec && weatherRec.suggestIndoor) {
                                addMessage('ğŸ’¡ **×”××œ×¦×”:** ×¨×•×¦×” ×©××—×¤×© ×œ×š ××ª×§×Ÿ ××§×•×¨×” ×‘××§×•×? (××•×œ× ×¡×¤×•×¨×˜, ××ª×§×Ÿ ×›×•×©×¨, ×•×›×•\') ğŸ¢', 'bot');
                                return;
                            }
                        }
                    }
                    
                    // Also add context-aware feedback when we have location but indoor facility
                    if (hasBasicInfo && !conversationState.weatherChecked && 
                        !OUTDOOR_FACILITIES.includes(conversationState.slots.facility_type)) {
                        
                        addMessage('×¨×’×¢ ××—×“, ×‘×•×“×§ ××ª ××–×’ ×”××•×•×™×¨... ğŸŒ¤ï¸', 'bot');
                        showTypingIndicator();
                        
                        const weatherData = await getWeatherData(conversationState.slots.location);
                        conversationState.weatherData = weatherData;
                        conversationState.weatherChecked = true;
                        
                        hideTypingIndicator();
                        
                        if (weatherData) {
                            const contextualFeedback = getContextualWeatherFeedbackForIndoor(weatherData, conversationState.slots.facility_type);
                            if (contextualFeedback) {
                                addMessage(contextualFeedback, 'bot');
                            }
                        }
                    }
                    
                    // Handle weather suggestion responses
                    if (conversationState.weatherChecked && message.toLowerCase().includes('××§×•×¨×”')) {
                        conversationState.slots.facility_type = '××•×œ×';
                        addMessage('××¢×•×œ×”! ××—×¤×© ×œ×š ××ª×§×Ÿ ××§×•×¨×”... ğŸ¢', 'bot');
                    }
                    
                    const missingSlots = getMissingSlots();
                    
                    // If we still need basic info, ask for it
                    if (missingSlots.length > 0) {
                        const question = askForMissingInfo(missingSlots);
                        if (question) {
                            addMessage(question, 'bot');
                            return;
                        }
                    }
                    
                    // We have all info - perform search
                    const facilities = filterFacilities();
                    
                    if (facilities.length > 0) {
                        // Add weather context to results if we have weather data
                        if (conversationState.weatherData && conversationState.weatherChecked) {
                            const contextualSummary = getWeatherContextForResults(
                                conversationState.weatherData, 
                                conversationState.slots.facility_type,
                                facilities.length
                            );
                            if (contextualSummary) {
                                addMessage(contextualSummary, 'bot');
                            }
                        }
                        
                        // Use pagination to display results
                        displayPaginatedResults(facilities, true);
                    } else {
                        addMessage('×œ× ××¦××ª×™ ××ª×§× ×™× ×©××ª××™××™× ×œ×‘×§×©×ª×š. ğŸ˜”<br><br>ğŸ’¡ × ×¡×” ×œ×©× ×•×ª ××ª ×”×§×¨×™×˜×¨×™×•× ×™× ××• ×œ×›×ª×•×‘ ×‘×§×©×” ××—×¨×ª.', 'bot');
                    }
                    
                    // Reset conversation state
                    conversationState = {
                        intent: null,
                        slots: {
                            location: null,
                            facility_type: null,
                            accessibility: null,
                            parking: null,
                            lighting: null,
                            time: null
                        },
                        weatherChecked: false,
                        weatherData: null,
                        searchResults: [],
                        currentPage: 0,
                        resultsPerPage: 3,
                        showMorePerPage: 10
                    };
                }
                
            } catch (error) {
                hideTypingIndicator();
                console.error('Error processing message:', error);
                addMessage('âš ï¸ ××¦×˜×¢×¨, ××™×¨×¢×” ×©×’×™××”. ×× × × ×¡×” ×©×•×‘.', 'bot');
            }
        }

        // UI functions
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message && isDataLoaded) {
                addMessage(message, 'user');
                input.value = '';
                setTimeout(() => processMessage(message), 500);
            }
        }

        function addMessage(content, sender) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble';
            bubbleDiv.innerHTML = content;
            
            messageDiv.appendChild(bubbleDiv);
            messagesContainer.insertBefore(messageDiv, document.getElementById('typingIndicator'));
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'block';
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'none';
        }

        function startNewConversation() {
            const messagesContainer = document.getElementById('messagesContainer');
            const typingIndicator = document.getElementById('typingIndicator');
            
            while (messagesContainer.firstChild && messagesContainer.firstChild !== typingIndicator) {
                messagesContainer.removeChild(messagesContainer.firstChild);
            }
            
            conversationState = {
                intent: null,
                slots: {
                    location: null,
                    facility_type: null,
                    accessibility: null,
                    parking: null,
                    lighting: null,
                    time: null
                },
                weatherChecked: false,
                weatherData: null,
                searchResults: [],
                currentPage: 0,
                resultsPerPage: 3,
                showMorePerPage: 10
            };
            
            setTimeout(() => {
                addMessage('×©×œ×•×! ××™×š ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š ×”×™×•×? ğŸ˜Š<br><br>×× ×™ ×›××Ÿ ×›×“×™ ×œ×¢×–×•×¨ ×œ×š ×œ××¦×•× ××ª ××ª×§×Ÿ ×”×¡×¤×•×¨×˜ ×”××•×©×œ× ×‘×™×©×¨××œ.', 'bot');
            }, 500);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('ğŸš€ SportsBuddy AI - Initializing...');
            await loadSportsData();
        });

        // Make functions globally accessible
        window.handleKeyPress = handleKeyPress;
        window.sendMessage = sendMessage;
        window.startNewConversation = startNewConversation;
        window.showMoreResults = showMoreResults;
    </script>
</body>
</html>
